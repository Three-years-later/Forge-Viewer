# [Understand the code](https://forge.autodesk.com/developer/learn/viewer-app/understand-code)

### 在这个部分：

1. Web服务器：Express服务器
2. 欢迎页面：/
3. 身份验证：/api/forge/oauth
4. 存储桶创建：/api/forge/datamanagement/bucket/create
5. 获取存储桶详细信息：/api/forge/datamanagement/bucket/detail
6. 上传表格：/upload.html
7. 保存文件：/api/forge/datamanagement/bucket/upload
8. 转换： /api/forge/modelderivative
9. viewer：/viewer.html

流程如下所示：

![示例图01](https://developer.static.autodesk.com/forgeunified/releases/current/1.0.0.20200617231558/images/3d_viewer_app_workflow.png)

## 理解代码

让我们深入研究代码并尝试理解其逻辑。

>**总结**：这是4个对于我们的应用正常运行必不可少的文件。
>
> * start.js
> * www/index.html
> * www/upload.html
> * www/viewer.html

为了简单起见，我们将所有代码保存在单个文件start.js中。但是，您可以根据需要将它们分成逻辑块。

>If you are not confident with using the Forge Authentication API, you may want to look at the [Two-Legged Authentication walkthrough](https://forge.autodesk.com/developer/learn/twolegged-auth/overview).

### 网络服务器

Express (和 Node.js) 需要3个代码块才能启动Web服务器.

>我们将介绍设置基本Web服务器的基本知识。如果您想了解更多信息，请参阅<https://expressjs.com/>.

让我们向下滚动到start.js第23至25行。我们正在导入一些要由我们的应用程序使用的包.

* express是网络服务器
* Axios是针对浏览器和node.js的基于Promise的HTTP客户端
* bodyParser是使我们的服务器能够读取JSON响应的实用程序

这些软件包将在您运行时自动安装npm install。我们将在下一部分[4.一起运行代码].

**@start.js Line 23 to 25:**

```js
var express = require('express');        // 为网络服务器
var Axios = require('axios');            // 一个基于Promise的HTTP客户端
var bodyParser = require('body-parser'); // 读取JSON响应的实用程序
```

接下来，我们将Express Web服务器配置为接受JSON文件格式，并设置要保存在名为'www' 的文件夹中的静态文件.

文件夹/ www是我们保存.html文件的位置.

**@start.js Line 27 to 30:**

```js
// 设置Express Web服务器
var app = express();
app.use(bodyParser.json());
app.use(express.static(__dirname + '/www'));
```

最后，我们将服务器设置为监听端口3000。因此，当您访问我们的应用程序时，必须在URL后面附加：3000。例如，要访问localhost，您必须指定<http://localhost:3000>，而不仅仅是<http://localhost>.

>您会看到许多带有console.log()的行，这里没有详细说明。这些行用于调试。他们将结果输出到我们的终端，以便我们检查进度。
>
>您可以删除这些行，并且代码示例仍将起作用。

**@start.js Link 32 to 36**

```js
// 这是用于Web服务器开始监听端口3000
app.set('port', 3000);
var server = app.listen(app.get('port'), function () {
    console.log('Server listening on port ' + server.address().port);
});
```

### 欢迎页面

默认情况下，当您转到URL<http://localhost:3000>时，服务器将自动加载www/index.html.

这是我们应用程序的欢迎页面，它是带有最少代码的简单HTML页面.

只有第30行对我们的应用正常运行至关重要.

该行仅显示一个超链接，单击该超链接会将用户重定向到本地Web服务器上的另一个URL, <http://localhost:3000/api/forge/oauth>.

>我们的源代码中没有名为 "/api/forge/oauth" 的文件.但是我们接下来将设置该虚拟路径.
>
>这些虚拟路径也称为 "Routes". 此技术称为 "Routing".
>
>[阅读有关Express Routing的更多信息](https://expressjs.com/en/guide/routing.html).

**@index.html full source code:**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Autodesk Forge: Walkthrough Tutorial</title>

    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    
    <style>
        /** 只需简单的CSS样式即可使此页面更好看 **/
        main {
            padding: 2em;
        }
        main a {
            background-color: #3252aa;
            color: #fff;
            text-decoration: none;
            padding: 1em;
        }
    </style>
</head>

<body>
    <main id="main">
        <a href="/api/forge/oauth">Authorize me!</a>
    </main>
</body>

</html>
```

您可以尝试运行到目前为止已经讨论过的代码段来测试Web服务器.跳过运行代码以测试您的服务器.您应该只会看到一个蓝色链接.

>当您单击按钮时，您会收到一条错误消息，因为我们尚未创建虚拟路径 /api/forge/oauth .

![Online Viewer Walkthrough](https://developer.static.autodesk.com/forgeunified/releases/current/1.0.0.20200617231558/images/3d_viewer_app_1.png)

### 认证方式

Forge支持两种身份验证：:

* Two-Legged 认证
* Three-Legged 认证

在本演练中，我们将使用 Two-Legged Authentication.

>简而言之, Two-Legged authentication 是最简单的，通常是许多API库中的默认设置.
>
>之所以称为two-legged这种流程，是因为您的应用程序和Forge平台是two legs.
>
>有关这两种认证类型的更多信息，请参考此[API基础](https://forge.autodesk.com/en/docs/oauth/v2/developers_guide/basics/).

现在，在首选的编辑器中打开文件"start.js"，然后滚动到第43和44行.

这2行会自动检索保存在本地环境变量中的Client ID和Secret。

>将ID＆Secret定义为环境变量很重要，这样它们就不会在源代码中暴露给其他用户。我们将在稍后的“运行代码”中定义它们.

**@start.js**

```js
var FORGE_CLIENT_ID = process.env.FORGE_CLIENT_ID;
var FORGE_CLIENT_SECRET = process.env.FORGE_CLIENT_SECRET;
```

在第45行，我们定义一个空变量，稍后将使用它存储访问令牌.

之后，我们在第46行设置作用域以指定访问权限.

它们包括:

* **data**:**read** 从存储桶中读取文件
* **data**:**write** 编辑存储桶中的文件
* **data**:**create** 在我们的存储桶中创建文件
* **bucket**:**read** 读取bucket
* **bucket**:**create** to 创建新的bucket

在第47行，我们将使用 querystring (包含在 Node.js 中) 将数据转换为所需的格式.

**@start.js:**

```js
var access_token = '';
var scopes = 'data:read data:write data:create bucket:create bucket:read';
const querystring = require('querystring');
```

在第50行中，我们使用 Express' app.get() 创建一个监听path的新路由<http://localhost:3000/api/forge/oauth>.

当您单击 Authorize me! 欢迎页面上的按钮，您将被重定向到<http://localhost:3000/api/forge/oauth>.

**@start.js:**

```js
// // Route /api/forge/oauth
app.get('/api/forge/oauth', function (req, res) {
```

现在，在 /api/forge/oauth 路由中，我们将使用您的Client ID和Secret，使用Axios将POST请求发送到端点"<https://developer.api.autodesk.com/authentication/v1/authenticate>".

>查看[Two-Legged Authentication的HTTP规范](https://forge.autodesk.com/developer/learn/twolegged-auth/overview).

**On success:**

如果POST请求成功,将执行.then()其中的代码. 我们会将令牌保存到名为access_token的变量中，以备将来使用. 然后，将该应用程序路由到<http://localhost:3000/api/forge/datamanagement/bucket/create>,这会为我们的应用程序创建一个共享存储桶.

>如果您现在迷失方向, 您可能要重新访问 Two-Legged Authentication walkthrough.

**On failure:**

如果POST请求失败, 将执行catch()其中的代码. 我们只是在页面上返回错误消息.

```js
app.get('/api/forge/oauth', function (req, res) {
  Axios({
    method: 'POST',
    url: 'https://developer.api.autodesk.com/authentication/v1/authenticate',
    headers: {
      'content-type': 'application/x-www-form-urlencoded',
    },
    data: querystring.stringify({
      client_id: FORGE_CLIENT_ID,
      client_secret: FORGE_CLIENT_SECRET,
      grant_type: 'client_credentials',
      scope: scopes
    })
  })
    .then(function (response) {
      // Success
      access_token = response.data.access_token;
      console.log(response);
      res.redirect('/api/forge/datamanagement/bucket/create');
    })
    .catch(function (error) {
      // Failed
      console.log(error);
      res.send('Failed to authenticate');
    });
});
```

### Bucket Creation

应用收到访问令牌后，我们就可以继续创建应用存储桶来存储文件.

>在数据管理中，文件存储在称为buckets的容器中.

在第106和107行, 我们定义了bucket key 和 policy key.

>我们可以将任何名称设置为存储桶键。此后，无论何时将对象上传到存储桶，都将使用存储桶键来访问存储桶。
>
>存储桶密钥在所有应用程序和区域中必须是全局唯一的，否则调用将失败。
>
>这就是为什么我们给它添加了您的ID的原因，因此存储桶密钥在所有其他帐户的所有存储桶中都是唯一的。

策略密钥(policy key)是指我们存储桶(bucket)的保留策略.

* transient: 类似于缓存的存储，只能持续24小时，非常适合临时对象.
* temporary: 可以保存30天的存储.
* persistent: 持续存储直到被删除的存储.

在本演练中，我们使用临时策略(transient policy)，因此所有对象仅保留24小时.

```js
const bucketKey = FORGE_CLIENT_ID.toLowerCase() + '_tutorial_bucket'; // 带ID的前缀，因此存储桶密钥在所有其他帐户的所有存储桶中都是唯一的
const policyKey = 'transient'; // Expires in 24hr
```

接下来，在/api/forge/datamanagement/bucket/create路由中，我们将使用之前获得的访问令牌(access)创建一个存储桶.

我们将使用Axios将POST请求发送到端点<https://developer.api.autodesk.com/oss/v2/buckets>，并在请求正文中指定存储桶键和策略键。

>从现在开始，我们不需要我们的客户ID和密码，因为我们将使用之前获得的应用程序访问令牌.

**@start.js Line 109 to 139**

```js
// 路由 /api/forge/datamanagement/bucket/create
app.get('/api/forge/datamanagement/bucket/create', function (req, res) {
  // 使用先前路由的访问令牌创建应用程序共享存储桶
  // 在本教程中，我们将使用此存储桶来存储所有文件
  Axios({
    method: 'POST',
    url: 'https://developer.api.autodesk.com/oss/v2/buckets',
    headers: {
      'content-type': 'application/json',
      Authorization: 'Bearer ' + access_token
    },
    data: JSON.stringify({
      'bucketKey': bucketKey,
      'policyKey': policyKey
    })
  })
    .then(function (response) {
      // Success
      console.log(response);
      res.redirect('/api/forge/datamanagement/bucket/detail');
    })
    .catch(function (error) {
      if (error.response && error.response.status == 409) {
        console.log('Bucket already exists, skip creation.');
        res.redirect('/api/forge/datamanagement/bucket/detail');
      }
      // Failed
      console.log(error);
      res.send('Failed to create a new bucket');
    });
});
```

**On success:**

如果存储桶创建成功，则.then中的代码将运行。我们会将终端用户重定向到/api/forge/datamanagement/bucket/detail.

**@start.js Line 125 to 129**

```js
.then(function (response) {
    // Success
    console.log(response);
    res.redirect('/api/forge/datamanagement/bucket/detail');
})
```

**On failure:**

如果在创建存储桶时发生错误，它将被捕获在.catch中.

我们正在专门检查是否返回了状态码为409的错误。状态码409指示存储桶创建失败，因为存储桶密钥已经存在.

由于存储桶是在我们第一次运行应用程序时创建的，因此所有后续运行都会导致存储桶创建失败，状态码为409。在这种情况下，我们还将终端用户重定向到/api/forge/datamanagement/bucket/detail.

如果其他任何操作失败，我们将结束路由并返回错误消息.

**@start.js Line 130 to 138**

```js
.catch(function (error) {
  if (error.response && error.response.status == 409) {
    console.log('Bucket already exists, skip creation.');
    res.redirect('/api/forge/datamanagement/bucket/detail');
  }
  // Failed
  console.log(error);
  res.send('Failed to create a new bucket');
});
```

### 获取Bucket详细信息

我们要确保在允许终端用户上传文件之前成功创建了存储桶.

为此，我们只需尝试检索存储桶的详细信息.

在/api/forge/datamanagement/bucket/detail路由中, 让我们再次使用Axios并将GET请求发送到端点<https://developer.api.autodesk.com/oss/v2/buckets/:bucketKey/details>. 我们用存储桶密钥(bucket key)替换:bucketKey.

我们在存储桶密钥上使用encodeURIComponent()以确保其对URL友好.

**On success:**

.then()中的代码将运行并将终端用户重定向到/upload.html.

**On failure:**

.catch()中的代码将运行. 我们只是在页面上显示错误消息.

```js
// Route /api/forge/datamanagement/bucket/detail
app.get('/api/forge/datamanagement/bucket/detail', function (req, res) {
  Axios({
    method: 'GET',
    url: 'https://developer.api.autodesk.com/oss/v2/buckets/' + encodeURIComponent(bucketKey) + '/details',
    headers: {
      Authorization: 'Bearer ' + access_token
    }
  })
    .then(function (response) {
      // Success
      console.log(response);
      res.redirect('/upload.html');
    })
    .catch(function (error) {
      // Failed
      console.log(error);
      res.send('Failed to verify the new bucket');
    });
});
```

### 上传表单

上传表单由一个文件输入和一个提交按钮组成. 终端用户可以从桌面选择文件，然后将其上传到我们的存储桶中.

该表格将发布到/api/forge/datamanagement/bucket/upload路径，该路径会将文件保存到我们的应用程序存储桶中.

**@www/upload.html full source code:**

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Autodesk Forge: 3D Viewer App Sample</title>

  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
  <meta http-equiv="pragma" content="no-cache" />
  
  <style>
    /** Just simple CSS styling to make this page a little nicer **/
    main {
      padding: 2em;
    }
    main button {
      background-color: #3252aa;
      color: #fff;
      text-decoration: none;
      padding: 1em;
      border-radius: 2px;
      transition: background-color 0.2s ease;
    }
    main button:hover {
      background-color: #ff5800;
    }
    main input {
      background-color: #eee;
      padding: 1em;
    }
  </style>
</head>

<body>
  <main id="main">
    <h1>Upload a supported file to bucket</h1>
    <form action="/api/forge/datamanagement/bucket/upload" enctype="multipart/form-data" method="post">
      <input type="file" name="fileToUpload"/>
      <button type="submit">Submit</button>
    </form>
    <p></p>
    <p>Supported formats can be found here:</p>
    <p><a target="_blank" href="https://developer.autodesk.com/en/docs/model-derivative/v2/overview/supported-translations/">https://developer.autodesk.com/en/docs/model-derivative/v2/overview/supported-translations/</a></p>
  </main>
</body>

</html>
```

![Online Viewer Walkthrough](https://developer.static.autodesk.com/forgeunified/releases/current/1.0.0.20200617231558/images/3d_viewer_app_2.png)

### 保存存档Save File

首先让我们检查路由/api/forge/datamanagement/bucket/upload的代码.

该代码块乍一看可能令人生畏。但是，当我们将其分解成小块并仔细查看每块时，它看起来会更简单.

**@start.js Line 162 to 199:**

```js
// 用于将源码转换为Base64编码的字符串
var Buffer = require('buffer').Buffer;
String.prototype.toBase64 = function () {
  // Buffer是Node.js的一部分，用于与TCP流、文件系统操作和其他上下文中的八字节流进行交互。
  return new Buffer(this).toString('base64');
};

var multer = require('multer');         // 处理文件上传
var upload = multer({ dest: 'tmp/' }); // 将文件保存到本地/tmp文件夹

// 路由 /api/forge/datamanagement/bucket/upload
app.post('/api/forge/datamanagement/bucket/upload', upload.single('fileToUpload'), function (req, res) {
  var fs = require('fs'); // 用于读取文件的Node.js文件系统
  fs.readFile(req.file.path, function (err, filecontent) {
    Axios({
      method: 'PUT',
      url: 'https://developer.api.autodesk.com/oss/v2/buckets/' + encodeURIComponent(bucketKey) + '/objects/' + encodeURIComponent(req.file.originalname),
      headers: {
        Authorization: 'Bearer ' + access_token,
        'Content-Disposition': req.file.originalname,
        'Content-Length': filecontent.length
      },
      data: filecontent
    })
      .then(function (response) {
        // Success
        console.log(response);
        var urn = response.data.objectId.toBase64();
        res.redirect('/api/forge/modelderivative/' + urn);
      })
      .catch(function (error) {
        // Failed
        console.log(error);
        res.send('Failed to create a new object in the bucket');
      });
  });
});
```

我们使用名为Multer的功能来帮助我们处理文件上传，我们指定服务器上的目标文件夹必须为/tmp(在本例中，/tmp在您的计算机上，因为它是作为服务器运行的.

**@start.js Line 170 to 171:**

```js
var multer = require('multer');         // 处理文件上传
var upload = multer({ dest: 'tmp/' }); // 将文件保存到本地/tmp文件夹
```

在第174行，Multer读取终端用户文件，上传并保存到/tmp文件夹中.

**@start.js Line 174:**

```js
upload.single('fileToUpload')
```

在第176行，fs从/tmp文件夹中读取文件。注意，fs是第175行上分配给Node.js文件系统模块的变量.

**@start.js Line 175 to 176:**

```js
var fs = require('fs'); // 用于读取文件的Node.js文件系统
fs.readFile(req.file.path, function (err, filecontent) {
```

从第177行开始，我们使用Axios发送一个PUT请求到端点https://developer.api.autodesk.com/oss/v2/buckets/:bucketKey/objects/:objectName。我们用桶密钥(bucket key)替换:bucketKey，用文件名(file name)替换:objectName.

我们发送应用程序access token, 默认文件名(file name)和文件大小作为标题参数.

最后，传递请求主体中的文件内容(数据).

>有关头部的更多信息，请参考关于[PUT: Object into Bucket]的文档.

**@start.js Line 178 to 186:**

```js
Axios({
  method: 'PUT',
  url: 'https://developer.api.autodesk.com/oss/v2/buckets/' + encodeURIComponent(bucketKey) + '/objects/' + encodeURIComponent(req.file.originalname),
  headers: {
    Authorization: 'Bearer ' + access_token,
    'Content-Disposition': req.file.originalname,
    'Content-Length': filecontent.length
  },
  data: filecontent
})
```

**On success:**

如果请求成功，.then()中的代码将运行.

在第190行，我们将源码URN转换为Base64格式。这是Model Derivative API的要求.

**@start.js Line 190:**

```js
var urn = response.data.objectId.toBase64();
```

toBase64()是我们在第163到168行中创建的原型方法.

>Buffer是一个Node.js函数，用于与TCP流、文件系统操作和其他上下文中的八字节流进行交互。

**@start.js Line 163 to 168:**

```js
var Buffer = require('buffer').Buffer;
String.prototype.toBase64 = function () {
    // Buffer是Node.js的一部分，用于与TCP流、文件系统操作和其他上下文中的八字节流进行交互.
    return new Buffer(this).toString('base64');
};
```

成功上传文件后，在第191行，我们重定向到路由/api/forge/modelderivative ，并将编码的对象ID(urn)作为参数附加到路由.

**@start.js Line 191:**

```js
res.redirect('/api/forge/modelderivative/' + urn);
```

### Translation

接下来，我们将上传的文件转换为可以在viewer中显示的格式。在本演练中，我们将使用Model Derivative API将其转换为SVF格式.

>Model Derivate API允许你将超过70种不同类型的文件转换成衍生文件(从另一种格式的源文件派生出的输出文件).
>
>访问[受支持的翻译]以获取受支持格式的完整列表.

让我们创建一个名为/api/forge/modelderivative的新路由来帮助我们进行转换.

注意，在第202行，新路由看起来与其他路由略有不同。它在斜杠/:urn后面包含一个冒号.

这意味着任何跟随/api/forge/modelderivative/的字符串都将作为参数被传递到函数中，它的名字是urn.

例如，如果我们输入URL http://localhost/api/forge/modelderivative/123，参数urn的值就是123，那么Express服务器就不会抛出错误.

>有关带参数的快速路由的更多信息，请参阅<https://expressjs.com/en/guide/routing.html>.

**@start.js Line 202:**

```js
app.get('/api/forge/modelderivative/:urn', function (req, res) {
```

以这种方式传递的所有参数都包含在req.params中.

在第208行，我们从req.params中提取urn值.

**@start.js Line 203:**

```js
var urn = req.params.urn;
```

然后将输出类型设置为svf，视图设置为2d和3d.

总之，这是告诉转换器获取urn引用的对象，并将其转换为2D和3D视图的svf格式.

**@start.js Line 204 to 205:**

```js
var format_type = 'svf';
var format_views = ['2d', '3d'];
```

然后在第206行，我们使用Axios向端点发送POST请求<https://developer.api.autodesk.com/modelderivative/v2/designdata/job>.

我们将访问令牌(access token)指定为头参数，并在正文中指定urn和输出选项(output options).

>有关更多输出选项，请参阅[Model Derivative POST job]上的文档.

**On success:**

如果转换成功，它将执行.then() block，这将把用户重定向到第230行上的page /viewer.html.

**On failure:**

如果转换失败，它将执行.catch() block，在该块中我们将返回一条错误消息.

>注意，在第230行中，我们将urn值放置在问号的右侧，而不是斜杠之后.
>
>在问号右边指定的选项称为查询字符串参数。在本例中，查询字符串参数是urn=<some value>.
>
>我们将urn作为查询字符串参数传递，因为我们希望前端JavaScript能够轻松地访问这个值.

```js
Axios({
  method: 'POST',
  url: 'https://developer.api.autodesk.com/modelderivative/v2/designdata/job',
  headers: {
    'content-type': 'application/json',
    Authorization: 'Bearer ' + access_token
  },
  data: JSON.stringify({
    'input': {
      'urn': urn
    },
    'output': {
      'formats': [
        {
          'type': format_type,
          'views': format_views
        }
      ]
    }
  })
})
  .then(function (response) {
    // Success
    console.log(response);
    res.redirect('/viewer.html?urn=' + urn);
  })
  .catch(function (error) {
    // Failed
    console.log(error);
    res.send('Error at Model Derivative job.');
  });

```

### Viewer

现在，真正的魔力！

我们将创建一个viewer.html页面来显示转换后的SVF文件.

>到目前为止，我们编写的所有JavaScript都在start.js中。
>
>该脚本在服务器上运行。
>
>所有函数和变量只能由服务器访问。客户端用户无法从其浏览器中查看或控制代码。
>
>我们称其为后端 JavaScript。

![Online Viewer Walkthrough](https://developer.static.autodesk.com/forgeunified/releases/current/1.0.0.20200617231558/images/3d_viewer_app_3.png)

让我们看一下位于walkthrough / www / viewer.html的文件.

它不像在index.html和upload.html中看到的那样简单.

There are 3 main components within this file.

* External libraries
* HTML code
* Frontend JavaScript

#### External libraries

The core libraries for our viewer are imported on lines 15 to 16.

第15行是用于设置Autodesk Viewer工具样式的CSS文件。没有它，我们的Viewer应用程序将没有缩放，平移等所需的工具.

第16行是JavaScript，可让我们使用Autodesk.ViewingAPI在专业的3D查看块上显示SVF文件.

> 包括这些脚本会暴露一个Autodesk全局命名的变量，即使我们没有在任何地方定义它.

**@viewer.html Line 15 to 16**

```html
<link rel="stylesheet" href="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/style.min.css" type="text/css">
<script src="https://developer.api.autodesk.com/modelderivative/v2/viewers/7.*/viewer3D.min.js"></script>
```

在第13行，我们包含一个第三方库jQuery.

>jQuery对于Autodesk.Viewing不是必需的. 我们将jQuery用于其Ajax函数和DOM操作器. 在查看前端JavaScript时，我们将进一步探索.

>包括此脚本在内，即使我们未在任何地方定义它，它也会全局公开一个名为jQuery的变量.

**@viewer.html Line 13:**

```html
<script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
```

#### HTML Code

除了通用HTML标记之外，只有一行HTML代码对我们的应用至关重要。

这是第28行。

这是一个占位符，用于调用Autodesk.Viewing API，并将其放在此div中。如果发生错误，错误消息也显示在此div中.

>请务必注意，该ID必须与我们在前端JavaScript中指定的ID匹配.
>
>在大多数浏览器中，ID区分大小写. 例如，myViewerdiv与MyViewerDiv不同.

**@viewer.html Line 28:**

```js
<div id="MyViewerDiv"></div>
```

#### 前端(Frontend) JavaScript

显示SVF文件的所有繁重工作都是由viewer.html中的JavaScript完成的.

HTML文件中<script>和</script>标记之间的任何JavaScript 都称为**Frontend** JavaScript.

我们之前导入的Autodesk和jQuery脚本也被视为Frontend脚本.

前端JavaScript和后端JavaScript之间的区别:

前端(Frontend) JavaScript	|后端(Backend) JavaScript
:-|:-|
从HTML文件中引用.	|不能放在HTML文件中或从HTML文件中访问.
运行在终端用户的web浏览器上，因此对终端用户可见，并可由他们更改.	|运行在Node.js服务器上，在终端用户的浏览器上不可见.
更改代码仅需要刷新页面.	|更改代码需要重新启动Node.js服务器.
该脚本不得包含任何敏感数据.	|可以包含敏感数据，例如API密钥.
Example: viewer.html	|Example: start.js

我们的自定义脚本从viewer.html的第30行开始.

>您应该将代码放在一个单独的.js文件中，并像我们对外部库所做的那样将其包括在内.
>
>但是，在本演练中，我们选择将代码放置在HTML文件中以简化文件夹结构.

现在，让我们分析代码.

我们定义了一个名为viewer的全局变量，它将在自定义脚本中访问。您将在我们的一些函数中看到这个变量.

此后，我们为viewer定义了一些选项.

>env应始终为AutodeskProduction，而api应为derivativeV2.
>
>对于上传到EMEA的模型，将api选项更改为derivedV2_EU.

getAccessToken使用函数getForgeToken（我们有意删除括号）从Nodejs服务器检索只读访问令牌.

**@viewer.html Line 31 to 36:**

```js
var viewer;
var options = {
    env: 'AutodeskProduction',
    api: 'derivativeV2', // 待办事项：对于上传到EMEA的模型，将此选项更改为'derivativeV2_EU'
    getAccessToken: getForgeToken
};
```

让我们看一下viewer.html的第91至98 行.

我们使用jQuery ajax()函数来获取route /api/forge/oauth/public，这是一个新的路由.

因为终端用户可以访问这段代码，所以我们不想公开/api/forge/oauth的完全访问令牌.

**@viewer.html Line 91 to 98:**

```js
function getForgeToken(callback) {
  jQuery.ajax({
    url: '/api/forge/oauth/public',
    success: function (res) {
      callback(res.access_token, res.expires_in);
    }
  });
}
```

现在，让我们回到start.js来创建route /api/forge/oauth/public来返回只读访问令牌.

代码对您来说熟悉吗？

它看起来与route /api/forge/oauth非常相似，不是吗?

我们使用Axios将POST请求发送到相同的端点<https://developer.api.autodesk.com/authentication/v1/authenticate>.

但这一次，在第90行，我们没有使用前面定义的变量范围，而是使用了"viewables:read". 我们将访问限制为只读.

在第96行，我们将访问令牌和到期日期返回给终端用户，以便终端用户可以在Autodesk.Viewing API调用中使用它们. 我们没有全局保存令牌，因为我们不会在其他路由中使用此令牌.

>因为我们要将访问令牌返回给前端JavaScript，所以我们不想公开任何具有写访问权限的令牌.

**@start.js Line 77 to 103:**

```js
// Route /api/forge/oauth/public
app.get('/api/forge/oauth/public', function (req, res) {
  // 将公共令牌限制为只读
  Axios({
    method: 'POST',
    url: 'https://developer.api.autodesk.com/authentication/v1/authenticate',
    headers: {
      'content-type': 'application/x-www-form-urlencoded',
    },
    data: querystring.stringify({
      client_id: FORGE_CLIENT_ID,
      client_secret: FORGE_CLIENT_SECRET,
      grant_type: 'client_credentials',
      scope: 'viewables:read'
    })
  })
    .then(function (response) {
      // Success
      console.log(response);
      res.json({ access_token: response.data.access_token, expires_in: response.data.expires_in });
    })
    .catch(function (error) {
      // Failed
      console.log(error);
      res.status(500).json(error);
    });
});
```

您还记得start.js的第230行如何将查询字符串传递urn=\<value>给路由viewer吗?

此urn值显示在最终用户浏览器的地址栏上.

**@start.js Line 235:**

```js
res.redirect('/viewer.html?urn=' + urn);
```

浏览器显示的带有urn查询字符串的URL的示例:

```html
http://localhost:3000/viewer.html?urn=dXJuOmFkc2sub2JqZWN0czpvcy5vYmpO=
```

在viewer.html中，我们需要从地址栏中获取urn值.

由于这不是在前端JavaScript中直接实现的，为此，我们从第66行到第71行编写了一个名为getUrlParameter()的函数.

在第37行，我们调用函数getUrlParameter()从地址栏中获取对象的容器.

>在第37行中，必须包含字符串urn:和urn值. 这是Autodesk.Viewing API的要求.

**@viewer.html Line 82 to 87:**

```js
function getUrlParameter(name) {
  name = name.replace(/[[]/, '\\[').replace(/[\]]/, '\\]');
  var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
  var results = regex.exec(location.search);
  return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
}
```

**@viewer.html Line 37:**

```js
var documentId = 'urn:' + getUrlParameter('urn');
```

加载页面后，我们立即创建Autodesk.Viewing.GuiViewer3D（第42至46行）将对象加载到div占位符.

第41行将容器MyViewerDiv设置为我们的查看应用程序. 该名称必须与我们之前在HTML中定义的名称匹配.

>GuiViewer3D 将为我们提供一个不错的Web界面以及用于操作该对象的工具.

在第48行，我们传入documentId（对象的urn）和2个回调函数：onDocumentLoadSuccess和onDocumentLoadFailureOn.

顾名思义，如果文档成功加载，我们将调用函数onDocumentLoadSuccess. 如果文档加载失败，我们将调用函数onDocumentLoadFailure.

**@viewer.html Line 40 to 50:**

```js
Autodesk.Viewing.Initializer(options, function onInitialized(){
  // 找到3d viewer所在的元素.    
  var htmlElement = document.getElementById('MyViewerDiv');
  if (htmlElement) {
    // 在该元素中创建并启动viewer    
    viewer = new Autodesk.Viewing.GuiViewer3D(htmlElement);
    viewer.start();
    // 将文档加载到viewer中.
    Autodesk.Viewing.Document.load(documentId, onDocumentLoadSuccess, onDocumentLoadFailure);
  }
});
```

**On document load success:**

第60到61行检查默认的可见几何体. 如果没有，我们将不渲染任何东西并返回错误消息.

第66行会载入默认的可见内容.

>我们加载了默认的几何体. 实际上，您可能希望遍历由doc.getRoot().findAllViewables()返回的数组，并返回一个列表供最终用户选择要显示的数组.

**@viewer.html Line 56 to 70:**

```js
function onDocumentLoadSuccess(doc) {
  // 将默认的可见几何体加载到viewer中.
  // 使用该文档，我们可以访问root BubbleNode，该root BubbleNode引用了图表的根节点，该图包装了Manifest JSON中的每个对象.
  var viewable = doc.getRoot().getDefaultGeometry();
  if (viewable) {
    viewer.loadDocumentNode(doc, viewable).then(function(result) {
      console.log('Viewable Loaded!');
    }).catch(function(err) {
      console.log('Viewable failed to load.');
      console.log(err);
    }
    )
  }
}
```

**On document load failure:**

它只是在浏览器控制台中打印一条错误消息，并在MyViewerDiv占位符内的Web浏览器中写入一条消息.

>有关jQuery的html()的更多信息，请参阅<http://api.jquery.com/html/>.

**@viewer.html Line 75 to 78:**

```js
function onDocumentLoadFailure(viewerErrorCode) {
  console.error('onDocumentLoadFailure() - errorCode: ' + viewerErrorCode);
  jQuery('#MyViewerDiv').html('<p>Translation in progress... Please try refreshing the page.</p>');
}
```

----

### Next

4. Run the code
