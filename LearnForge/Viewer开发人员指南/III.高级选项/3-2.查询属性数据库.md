# 查询属性数据库

[属性数据库](https://forge.autodesk.com/en/docs/viewer/v7/reference/globals/PropertyDatabase/)包含构造模型的所有BIM数据，或制造模型的制造详细信息。 属性数据库保存在专用的[Web工作者](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API)上，并通过异步消息进行访问。

## Step 1: 编译自定义查询功能

查询函数必须命名为userFunction。 首先，编写一个简单的查询功能。

```js
function userFunction(pdb) {
    return 42;
}
```

普通查询功能尚未与**pdb**（属性数据库）交互。 我们将在第3步中详细介绍其实现，但现在，它返回的固定值为**42**。

## Step 2: 执行自定义查询功能

使用**viewer.model.getPropertyDb().executeUserFunction(userFunction)**返回一个**Promise**，该**Promise**使用**userFunction**的返回值进行解析。

```js
var thePromise = viewer.model.getPropertyDb().executeUserFunction( userFunction );
thePromise.then(function(retValue){
  console.log('retValue is: ', retValue); // prints 'retValue is: 42'
}).catch(function(err){
  console.log("Something didn't go right...")
  console.log(err);
});
```

执行上述代码段后，您将在浏览器的开发人员控制台中看到消息retValue为：42。

## Step 3: 查询属性数据库

此时修改**userFunction**属性，使其与属性数据库进行交互。

自定义查询功能的目的是返回模型中最大部分的ID。 为此，我们将迭代模型中的所有部件ID，并检查其*Mass*属性值。

由于属性数据库的数据布局，我们首先需要确定“质量”属性的索引。 更新自定义查询函数，如下所示：

```js
function userFunction(pdb) {

  //return 42;

  var attrIdMass = -1;

  // 遍历所有属性并找到我们需要的索引
  pdb.enumAttributes(function(i, attrDef, attrRaw){

      var name = attrDef.name;

      if (name === 'Mass') {
          attrIdMass = i;
          return true; // 停止遍历其余属性。
      }
  });
}
```

如果**attrIdMass**的值不同于-1，则说明模型的属性数据库包含其零件的"Mass"数据。 接下来，我们将对所有零件及其属性进行迭代，以找出最大的零件。

```js
function userFunction(pdb) {

  //return 42;

  var attrIdMass = -1;

  // 遍历所有属性并找到我们需要的索引
  pdb.enumAttributes(function(i, attrDef, attrRaw){

    var name = attrDef.name;

    if (name === 'Mass') {
      attrIdMass = i;
      return true; // 停止遍历其余属性。
    }
  });

  // 较早返回是模型不包含"Mass"数据。
  if (attrIdMass === -1)
    return null;

  // 现在遍历所有部分以找出最大的部分。
  var maxValue = 0;
  var maxValId = -1;
  pdb.enumObjects(function(dbId){

    // 对于每个部分，对其属性进行迭代。
    pdb.enumObjectProperties(dbId, function(attrId, valId){

      // 仅处理"Mass"属性。
    // 单词"Property"和"Attribute"可互换使用。
      if (attrId === attrIdMass) {

        var value = pdb.getAttrValue(attrId, valId);

        if (value > maxValue) {
          maxValue = value;
          maxValId = dbId;
        }

        // 找到"Mass"后，停止迭代其他属性。
        return true;
      }
    });
  });

  // Return results
  return {
    id: maxValId,
    mass: maxValue
  }
}
```

最后，步骤2中Promise的**resolve**功能也必须进行更新。 在这种情况下，我们将让观看者选择并聚焦（缩放）最大的部分。

```js
var thePromise = viewer.model.getPropertyDb().executeUserFunction( userFunction );
thePromise.then(function(retValue){

  //if (retValue === 42) {
  //  console.log('We got the expected value back.');
  //}

  if (!retValue) {
    console.log("Model doesn't contain property 'Mass'.");
    return;
  }

  var mostMassiveId = retValue.id;
  viewer.select(mostMassiveId);
  viewer.fitToView([mostMassiveId]);
  console.log('Most massive part is', mostMassiveId, 'with Mass:', retValue.mass);
});
```

## 最后总结

编译自己的userFunction时，请确保避免引用超出函数范围的对象。 这是因为该函数在发送给Web Worker消息时被序列化。
