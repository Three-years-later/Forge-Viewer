# Scene Builder(使用Scene Builder添加自定义几何)

使用Scene Builder扩展，您可以创建模型并将自己的对象添加到Forge Viewer。 这些对象的处理方式与来自下载模型的数据一样，但有一些限制：

* 仅支持3D对象，包括3D线和其他几何图形。
* 只能使用THREE.BufferGeometry对象。
* 线不使用THREE.Line对象渲染。 您必须在BufferGeometry上设置**isLine：true**属性。
* 相同的BufferGeometry不能用于直线和三角形。
* 类似地，使用BufferGeometry属性**isPoint：true**绘制点。
* 该模型没有属性数据库。您可以分配数据库ID，它们可以用于一起收集多个对象，但是* 不会与这些对象关联任何属性。
* 该模型是平面的，没有实例树。
* 可以与Scene Builder一起使用的唯一材质是MeshPhong，MeshBasic，LineBasic和Prism。

使用SceneBuilder添加的对象将像下载的模型一样呈现，因此，与使用叠加层不同，不会影响帧速率。 渲染许多对象将需要更长的时间才能完全渲染模型。 此外，尚未为Scene Builder模型实现空间加速器。

在本教程结束时，您将能够：

* 加载Scene Builder扩展，它使您可以访问ModelBuilder API。
* 使用ModelBuilder API创建自定义模型。
* 向模型添加自定义几何。

## Step 1: 加载扩展功能

像其他任何扩展一样，使用loadExtension加载Scene Builder扩展。

```js
await viewer.loadExtension('Autodesk.Viewing.SceneBuilder');
```

加载扩展后，您可以使用getExtension获得扩展。

```js
ext = viewer.getExtension('Autodesk.Viewing.SceneBuilder');
```

## Step 2: 创建模型

加载扩展后，您需要创建一个模型来保存要显示的对象。 扩展方法addNewModel用于执行此操作。 此方法创建模型，并返回可用于更新模型的ModelBuilder API。

```js
modelBuilder = await ext.addNewModel({
    conserveMemory: false,
    modelNameOverride: 'My Model Name'
});
```

注意addNewModel的两个可选参数，conserveMemory和modelNameOverride。 这是参数对新模型的影响：

* conserveMemory：更改LMV存储网格的方式。 默认值为false，将其设置为true会导致lmv通过为模型中的所有片段共享单个网格对象来节省内存。如果将其设置为true，则**addMesh()**方法不能用于添加片段。
* modelNameOverride：设置要在模型浏览器面板中显示的名称。如果您未设置此选项，则LMV将生成一个名称-**Scene Builder Model n**-其中n是新模型的模型ID。

## Step 3: 将自定义图形添加到模型

LMV使用其属性数据库ID标识对象。 每个对象可以包含多个**fragments**。 每个片段都有一些几何图形，材质和变换以将几何图形定位为3D。

使用ModelBuilder可以通过三种方式添加图形。

* 您可以分别使用三个创建和添加材料和几何，然后使用材料名称和几何ID添加片段。
* 您可以使用三个对象来创建材质和几何图形，并使用javascript对象添加片段。
* 您可以创建三个网格并使用三个网格对象添加片段。

您可以根据需要一起使用不同的方式。需要材料的ModelBuilder上的方法将接受添加到模型中的材料的名称或三种材料。如果尚未将这三种材料添加到模型中。类似地，几何ID或三个几何对象可以互换使用。

<font color=gray size=4>3.1 分别添加图形</font>

将材料添加到模型时，将为其分配名称。如果名称已被使用或材料已添加到其他模型，则操作将无法添加材料。

```js
purple = new THREE.MeshPhongMaterial({
    color: new THREE.Color(1, 0, 1)
});
modelBuilder.addMaterial('purple', purple);
```

将几何图形添加到模型时，ModelBuilder会分配并返回几何图形的ID。但是，如果已将几何图形添加到模型中，则该操作将失败。

```js
box = new THREE.BufferGeometry().fromGeometry(new THREE.BoxGeometry(10, 10, 10));
let id = modelBuilder.addGeometry(box);
```

添加材料和几何图形后，您可以使用材料名称和几何图形ID添加片段。

```js
const transform = new THREE.Matrix4().compose(
    new THREE.Vector3(-15, 0, 0),
    new THREE.Quaternion(0, 0, 0, 1),
    new THREE.Vector3(1, 1, 1)
);
modelBuilder.addFragment(1, 'purple', transform);
```

**addFragment**方法将返回一个ID，您可以使用该ID删除或更改片段的显示。

<font color=gray size=4>3.2 使用THREE objects添加图形</font>

添加图形的另一种机制是使用THREE objects。ModelBuilder将检查是否已添加对象，如果尚未添加，则添加它们。如果将任何对象添加到其他模型，则该操作将失败。您不能在模型之间共享THREE objects。 添加材料时，ModelBuilder会生成一个要使用的名称。生成的名称是**!!mtl-n**，其中n是材料的**id**属性的值。

```js
red = new THREE.MeshPhongMaterial({
  color: new THREE.Color(1, 0, 0)
});
torus = new THREE.BufferGeometry().fromGeometry(new THREE.TorusGeometry(10, 2, 32, 32));

const transform = new THREE.Matrix4().compose(
  new THREE.Vector3(19, 0, 0),
  new THREE.Quaternion(0, 0, 0, 1),
  new THREE.Vector3(1, 1, 1)
);
modelBuilder.addFragment(torus, red, transform);
```

<font color=gray size=4>3.3 使用THREE Mesh添加图形</font>

使用THREE Mesh添加图形类似于使用THREE objects添加图形，并且相同的限制适用于两者。当您要在THREE Mesh中保留所有THREE objects时，使用THREE Mesh是一个不错的选择。仅当调用新模型时conserveMemory方法不存在或设置为false时，此选项才有效。

```js
mesh = new THREE.Mesh(torus, purple);
mesh.matrix = new THREE.Matrix4().compose(
  new THREE.Vector3(0, 12, 12),
  new THREE.Quaternion(0, 0, 0, 1),
  new THREE.Vector3(1, 1, 1)
);
mesh.dbId = 100;    // Set the database id for the mesh
modelBuilder.addMesh(mesh);
```
